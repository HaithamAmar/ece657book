% Chapter 2
\section{Symbolic Integration and Problem-Solving Strategies}\label{chap:symbolic}
\graphicspath{{assets/lec2_part1/}}

\Cref{chap:intro} treated ``intelligence'' operationally: a system should represent a problem, choose actions, and verify or correct itself under constraints. This chapter makes that concrete with a deliberately small example---symbolic integration---where the system's actions are algebraic transformations. \Cref{fig:roadmap} situates this symbolic strand alongside the data-driven path.

We study symbolic problem solving through the lens of \emph{integration-by-transformation}: preserve meaning while rewriting an expression into a form that exposes a solution. The point is not the catalog of tricks in isolation, but the system-level pattern: explicit representations, meaning-preserving actions, heuristic branching with backtracking, and a clear goal test that certifies correctness.

It helps to separate transformations into two tiers: reliable moves that never change the antiderivative class (factoring constants, linear substitutions, polynomial division) and heuristic moves that may succeed only for certain structures. A practical policy is to apply every reliable step first, then branch judiciously through the heuristic catalog while keeping enough state to backtrack.

\begin{tcolorbox}[summarybox,title={Learning Outcomes}]
\begin{itemize}
    \item Decompose symbolic integration problems into safe vs.\ heuristic transformations and understand when each is appropriate.
    \item Trace the transformation-tree search (state save/restore, heuristics, termination) and connect it to broader notions of intelligent problem solving.
    \item Contrast symbolic transformation search with data-driven modeling pipelines and identify what each paradigm contributes.
\end{itemize}
\end{tcolorbox}

\begin{tcolorbox}[summarybox,title={Design motif}]
Meaning\hyp{}preserving moves plus a mechanical check: if \(F(x)\) is proposed as an antiderivative of \(f(x)\), then differentiating should recover the integrand on the declared domain, i.e., \(F'(x)=f(x)\) (equivalently, \(F'(x)-f(x)=0\)).
\end{tcolorbox}

\subsection{Context and Motivation}
\label{sec:symbolic_context_and_motivation}

Consider the task of solving an integral of the form
\[
\int f(x) \, dx,
\]
where \( f(x) \) may be a complicated function. Traditional approaches often rely on consulting integral tables or applying well-known formulas. For example, integrals such as
\[
\int \frac{1}{x} \, dx = \ln|x| + C.
\]
These are straightforward and can be solved by direct lookup or simple substitution.

However, many integrals encountered in practice do not match any entry in standard integral tables, nor do they succumb easily to elementary techniques. The integration-by-transformation view treats this as a search problem: propose meaning-preserving rewrites, backtrack when a branch gets harder, and verify candidates mechanically by differentiation.

\begin{tcolorbox}[summarybox,title={Aside: the Risch algorithm}]
The Risch algorithm \citep{Risch1969} decides whether an elementary antiderivative exists for a large class of integrands by reducing the problem to algebra over differential fields. Unfortunately its implementation is intricate, requires case explosions, and still leaves many useful nonelementary functions unresolved. Practical computer algebra systems therefore augment Risch-style decision procedures with heuristic transformations---the focus of this chapter---to keep runtimes bounded and to return human-readable answers when possible.
\end{tcolorbox}

\subsection{Problem Decomposition and Transformation}
\label{sec:symbolic_problem_decomposition_and_transformation}

A key insight in tackling complex integrals is to \emph{reduce} the problem into manageable subproblems. This involves applying \emph{transformations} to rewrite the integral into a form that is either directly solvable or closer to known forms.

\paragraph{Safe Transformations}

We define \emph{safe transformations} as invertible substitutions that allow back-substitution: if \(u=\phi(x)\) and \(F_u\) is an antiderivative of \(T[g](u)\), then \(F_u\!\circ\!\phi\) differentiates back to \(g(x)\). Safe transformations are algebraic substitutions or factorings that survive reversal. Examples include:

\begin{itemize}
  \item \textbf{Constant factor extraction:} If \(G\) is an antiderivative of \(g\), then \(a g\) has antiderivative \(a G\); differentiating confirms \(\frac{d}{dx}[a G(x)] = a g(x)\).
  \item \textbf{Linear substitution:} Let \(u = ax + b\) with \(a \neq 0\). Differentiating gives \(du = a\,dx\) and hence \(dx = \frac{du}{a}\); substituting shows that
  \[
    \int f(ax + b)\,dx = \frac{1}{a} \int f(u)\,du.
  \]
  This is the standard change-of-variables formula.
  \item \textbf{Polynomial division:} If \( p(x) \) and \( q(x) \) are polynomials with \(\deg p \geq \deg q\), then perform polynomial division:
  \[
  \frac{p(x)}{q(x)} = s(x) + \frac{r(x)}{q(x)},
  \]
  where \(\deg r < \deg q\). Linearity of integration lets us integrate \(s(x)\) term-by-term, while the proper fraction \(\frac{r(x)}{q(x)}\) can be addressed via partial fractions or further substitutions, yielding an equivalent antiderivative.
\end{itemize}

These transformations are \emph{safe} because they always preserve the integral's value and simplify the problem without introducing ambiguity. When a substitution transforms an integral over \(x \in [0,1]\) into \(\int_0^1 u^{b}(1-u)^{c}\,du\) with \(b,c > -1\), the resulting definite integral evaluates to a Beta function \(B(b+1,c+1)\); the Beta identity applies to that definite integral on \([0,1]\), and it is therefore customary to fall back on it when an elementary antiderivative is unavailable.

\paragraph{Example: Applying Safe Transformations}

Suppose we have an integral of the form
\[
\int a \cdot x^{b} (1 - x)^{c} \, dx,
\]
where \(a, b, c\) are constants. A safe transformation might be to factor out the constant \(a\) and then consider substitutions or binomial expansions that reduce the powers to known integrals (e.g., Beta-function evaluations when \(b\) and \(c\) are integers).

\subsection{Limitations of Safe Transformations}
\label{sec:symbolic_limitations_of_safe_transformations}

After exhaustively applying all safe transformations, we may still encounter integrals that do not match any known solvable form. At this point, the system must decide whether the problem is solvable by known methods or if alternative strategies are necessary.

\subsection{Heuristic Transformations}
\label{sec:symbolic_heuristic_transformations}

When safe transformations fail to yield a solution, we turn to \emph{heuristic transformations}, which are not guaranteed to succeed but often provide a path forward. These heuristics are based on experience, pattern recognition, and mathematical intuition.

\paragraph{Definition}

Heuristic transformations are problem-solving \emph{tricks} or \emph{strategies} that attempt to rewrite the integral into a solvable form by exploiting structural properties of the integrand. They may involve:

\begin{itemize}
  \item Trigonometric identities and substitutions, e.g., using relationships among \(\sin x\), \(\cos x\), \(\tan x\), \(\cot x\), \(\sec x\), and \(\csc x\).
  \item Algebraic manipulations that simplify complicated expressions.
  \item Variable substitutions that transform the integral into a standard form.
  \item Recognizing patterns such as functions of \(10x\) or other scaled arguments and applying appropriate scaling substitutions (e.g., if the integrand contains \(f(cx)\), introduce \(u = cx\) so that the scale factor is absorbed).
\end{itemize}

\paragraph{Example: Trigonometric Heuristics}

Consider an integral involving sine and cosine:
\[
\int \frac{\sin x}{\cos x} \, dx.
\]
Recognizing that \(\sin x / \cos x = \tan x\), we can rewrite the integral as
\[
\int \tan x \, dx = -\ln|\cos x| + C.
\]
which is a standard integral with the constant of integration explicitly noted.

Similarly, if the integrand involves expressions like \(\sin^2 x + \cos^2 x\), we can use the Pythagorean identity to simplify.

\paragraph{Heuristics as a Form of Intelligence}

The use of heuristic transformations reflects a form of mathematical intelligence: the ability to recognize patterns, apply non-obvious substitutions, and creatively manipulate expressions to reach a solution. Unlike safe transformations, heuristics may fail or lead to dead ends, but they expand the problem-solving repertoire beyond mechanical procedures.

\begin{tcolorbox}[summarybox,title={Absolute values and branches}]
\begin{itemize}
    \item \textbf{Square roots:} specify the sign/branch. If you drop \(|\cdot|\), restrict the substitution interval so the sign is fixed (e.g., \(\cos y \ge 0\) on \(y\in(-\pi/2,\pi/2)\) so \(\sqrt{1-\sin^2 y}=\cos y\)).
    \item \textbf{Logarithms:} default to \(\log|f(x)|\) unless you guarantee \(f\) keeps one sign on the declared domain.
    \item \textbf{Arctrig/hyperbolic inverses:} state principal values and any periodicity you rely on for back-substitution.
\end{itemize}
\end{tcolorbox}


\subsection{Summary of the Approach}
\label{sec:symbolic_summary_of_the_approach}

The overall strategy for symbolic integration can be summarized as follows:

\begin{enumerate}
  \item \textbf{Apply all safe transformations} to simplify the integral and attempt to match known solvable forms.
  \item \textbf{Re-evaluate the transformed integrand} to identify structural cues (symmetry, polynomial degree, trigonometric patterns).
  \item \textbf{Choose among multiple transformation paths} by comparing simple cost heuristics such as expression-tree depth, number of nonzero coefficients, or anticipated integration rules.
  \item \textbf{Fallback to heuristics and backtracking} when safe transformations stall, maintaining a stack of previous states to enable systematic exploration.
\end{enumerate}

\paragraph{Cost heuristic.} Score candidates by a triple: tree depth, number of nonlinear operators, and symbol count. The nonlinearity term counts transcendental nodes (e.g., trigonometric, exponential, logarithmic), while the symbol count tallies AST nodes excluding simple literals such as \(-1,0,1\). Prefer branches that reduce or preserve this triple, and break ties toward rules with known templates (e.g., partial fractions, reduction formulas).
% Part A worked example (continued)

\subsection{Heuristic Transformations: Revisiting the Integral with \texorpdfstring{\(1 - x^2\)}{1 - x squared}}
\label{sec:symbolic_heuristic_transformations_revisiting_the_integral_with_1_x_2_1_x_squared}

Recall the integral under consideration:
\begin{equation}
  \int \frac{4}{(1 - x^2)^{5/2}} \, dx.
  \label{eq:original_integral}
\end{equation}

For real-valued integration we restrict attention to \(|x| < 1\), ensuring the denominator \((1 - x^2)^{5/2}\) is well-defined and nonzero on the interval of interest.

When encountering expressions involving \(1 - x^2\), a classical heuristic substitution is:
\[
x = \sin y,
\]
which leverages the Pythagorean identity:
\[
1 - \sin^2 y = \cos^2 y.
\]

Applying this substitution transforms the integral into a trigonometric form that is often easier to handle.

\paragraph{Step 1: Substitution and Differential}

Set
\[
x = \sin y \quad \Longrightarrow \quad dx = \cos y \, dy.
\]
We take \(y = \arcsin x\) with \(y \in \left[-\frac{\pi}{2}, \frac{\pi}{2}\right]\) so that the substitution remains bijective on the domain \(|x| \le 1\), and note \(\cos y \ge 0\) on this interval so that \(\sqrt{1-\sin^2 y}=\cos y\) is consistent with the chosen branch.

Substituting into \eqref{eq:original_integral} and using \(dx = \cos y \, dy\) yields
\begin{align*}
\int \frac{4}{(1 - x^2)^{5/2}} \, dx &= \int \frac{4}{(1 - \sin^2 y)^{5/2}} \cos y \, dy \\
&= \int \frac{4\cos y}{(\cos^2 y)^{5/2}} \, dy \\
&= 4 \int \cos^{-4} y \, dy \\
&= 4 \int \sec^{4} y \, dy.
\end{align*}
The intermediate step \(\cos y \cdot \cos^{-5}y = \cos^{-4}y\) is made explicit so the exponent arithmetic is transparent.

Thus, the integral reduces to
\begin{equation}
  4 \int \sec^{4} y \, dy.
  \label{eq:sec4_integral}
\end{equation}

\paragraph{Step 2: Choosing the Next Transformation}

At this stage, two common safe transformations are available:

\begin{itemize}
  \item Express \(\sec^4 y\) in terms of \(\tan y\), using the identity \(\sec^2 y = 1 + \tan^2 y\), and then perform substitution \(u = \tan y\) with \(du = \sec^2 y \, dy\).
  \item Use reduction formulas for powers of secant directly, e.g.,
  \[
  \int \sec^{n} y \, dy = \frac{\sec^{n-2} y \tan y}{n-1} + \frac{n-2}{n-1} \int \sec^{n-2} y \, dy, \quad n > 1.
  \]
\end{itemize}
Standard reduction formulas provide a deterministic alternative if the substitution path is judged too costly.

The choice between these paths is nontrivial, especially for an automated system. Humans often pick the substitution \(u = \tan y\) intuitively because it simplifies the integral, but a machine requires a deterministic decision rule.

\paragraph{Step 3: Functional Composition and Path Selection}

To automate the choice, the system evaluates the \emph{functional composition} of the integral expressions along each path (e.g., measuring expression-tree depth, symbolic coefficient growth, or the number of distinct functions involved):

\begin{itemize}
  \item \textbf{Path 1:} Substitution \(u = \tan y\) reduces the integral to a polynomial in \(u\), which is straightforward to integrate.
  \item \textbf{Path 2:} Direct reduction of \(\sec^4 y\) may involve more complex recursive steps.
\end{itemize}

From a cost perspective, Path 1 is cheaper and more direct, so the system prioritizes it. However, if this path fails to yield a solution, the system must backtrack and attempt Path 2.

\paragraph{Two safe options from here}
\begin{itemize}
  \item \textbf{(a) Substitution \(u=\tan y\).} Since \(\sec^4 y\,dy = \sec^2 y\,(\sec^2 y\,dy)\) and \(\sec^2 y = 1 + \tan^2 y\), set \(u=\tan y\), \(du=\sec^2 y\,dy\):
  \[
  \begin{aligned}
  4 \int \sec^4 y\,dy
    &= 4 \int (1+u^2)\,du \\
    &= 4\left(u + \tfrac{u^3}{3}\right)+C \\
    &= 4\tan y + \tfrac{4}{3}\tan^3 y + C.
  \end{aligned}
  \]
  \item \textbf{(b) Reduction formula.} For even \(n>1\),
  \[
    \int \sec^{n} y \, dy = \frac{\sec^{n-2} y \tan y}{n-1} + \frac{n-2}{n-1} \int \sec^{n-2} y \, dy.
  \]
  Applying this with \(n=4\) gives \(\int \sec^{4} y \, dy = \tan y + \tfrac{1}{3}\tan^{3} y + C\), reproducing the same primitive without the \(u\)-substitution.
  \end{itemize}

\paragraph{Back-substitution and check}

Using \(\tan y = \dfrac{x}{\sqrt{1-x^2}}\), both paths yield:
\[
F(x) = 4 \left[ x (1 - x^2)^{-1/2} + \frac{x^3}{3(1 - x^2)^{3/2}} \right] + C.
\]
Differentiating term by term shows \(F'(x)=4(1-x^2)^{-5/2}\) on \(|x|<1\). Outside \((-1,1)\) the principal-branch integrand is complex-valued; a real continuation rewrites the integral as \(\int 4(x^2-1)^{-5/2}dx\) with \(x=\cosh t\).

\paragraph{Pattern rule}
For integrals of the form \(\int (1 - x^2)^{-k-1/2} dx\), the substitution \(x=\sin y\) reduces them to \(\int \sec^{2k} y\,dy\); apply the even-power reduction accordingly. This is why the \(1 - x^2\) pattern triggers the trigonometric branch.
% Part A worked example (continued)

\subsection{Example: Solving an Integral via Transformation Trees}
\label{sec:symbolic_example_solving_an_integral_via_transformation_trees}

The worked integral above shows how the search explored multiple branches (e.g., \(x=\sin y\) vs.\ \(x=\tanh u\)) while respecting the declared domain. Heuristic branches that do not fit the domain are pruned; competing safe branches (substitution vs.\ reduction) converge to the same antiderivative. The key insight is that solving integrals can be viewed as traversing a \emph{decision tree} of transformations, with goal tests supplied by residual checks and domain conditions.

\subsection{Transformation Trees and Search Strategies}
\label{sec:symbolic_transformation_trees_and_search_strategies}

\paragraph{Definition:} A \textbf{transformation tree} is a conceptual structure representing all possible sequences of transformations applied to an expression in an attempt to solve or simplify it.

\begin{itemize}
  \item Each node corresponds to a state of the expression.
  \item Edges correspond to transformations (safe or heuristic).
  \item Leaves correspond to either solved expressions or dead ends (no solution).
\end{itemize}

\Cref{fig:lec3_transform_tree} shows the actual tree explored for \(\int \frac{4}{(1-x^2)^{5/2}}\,dx\). Solid branches denote safe algebraic steps (guaranteed progress), while dashed branches illustrate heuristic substitutions that may fail and trigger backtracking. Computer algebra systems follow similar playbooks \citep{Bronstein2005,Risch1969}: a Risch-style decision core handles provably solvable cases, while a curated bank of heuristics (pattern rewrites, rational substitutions, special-function fallbacks) explores auxiliary branches with explicit depth/time budgets.

\begin{figure}[h]
        \centering
        \ifdefined\HCode
            % TeX4ht stability: avoid adjustbox in EPUB builds.
            \resizebox{\linewidth}{!}{%
                \begin{tikzpicture}[
                    node distance=1.2cm and 1.0cm,
                    base/.style={
                        rectangle,
                        rounded corners=3pt,
                        line width=1pt,
                        minimum width=38mm,
                        text width=36mm,
                        inner sep=3mm,
                        align=center,
                        font=\small\sffamily
                    },
                    safe/.style={
                        base,
                        draw=cbBlue!70!black,
                        fill=cbBlue!25,
                        label={[anchor=north east, font=\scriptsize\bfseries, text=cbBlue!70!black, inner sep=2pt, yshift=-1pt]north east:[S]}
                    },
                    heur/.style={
                        base,
                        draw=cbOrange!70!black,
                        fill=cbOrange!25,
                        dashed,
                        label={[anchor=north east, font=\scriptsize\bfseries, text=cbOrange!70!black, inner sep=2pt, yshift=-1pt]north east:[H]}
                    },
                    line/.style={
                        draw=gray!80,
                        line width=1pt,
                        rounded corners=4pt,
                        ->,
                        >=Stealth
                    }
                ]

                    % Level 0
                    \node[safe] (root) at (0,0) {\(\displaystyle \int \frac{4}{(1-x^2)^{5/2}}\,dx\)};

                    % Level 1
                    \node[safe] (factor) at (-4.2, -2.8) {Factor constants\\restrict \(|x|<1\)};
                    \node[heur] (letu)   at ( 4.2, -2.8) {Let \(u = 1-x^2\)};

                    % Level 2
                    \node[heur] (subs)   at (-6.5, -6.0) {Substitute \(x=\sin y\)};
                    \node[heur] (sinh)   at (-2.0, -6.0) {Try \(x=\tanh u\)\\(hyperbolic twin)};
                    \node[heur] (stall)  at ( 4.2, -6.0) {Heuristic stalls\\backtrack};

                    % Level 3
                    \node[safe] (dx)     at (-8.8, -9.0) {Use \(dx=\cos y\,dy\)};
                    \node[safe] (reduce) at (-4.2, -9.0) {Reduce to \(4\int \sec^4 y\,dy\)};

                    % Edges
                    \draw[line] (root.south) -- ++(0,-0.6) -| (factor.north);
                    \draw[line] (root.south) -- ++(0,-0.6) -| (letu.north);

                    \draw[line] (factor.south) -- ++(0,-0.6) -| (subs.north);
                    \draw[line] (factor.south) -- ++(0,-0.6) -| (sinh.north);

                    \draw[line] (letu) -- (stall);

                    \draw[line] (subs.south) -- ++(0,-0.6) -| (dx.north);
                    \draw[line] (subs.south) -- ++(0,-0.6) -| (reduce.north);

                    % Legend
                    \node[
                        draw=gray!30,
                        rounded corners,
                        fill=white,
                        inner sep=8pt,
                        minimum width=10cm,
                        minimum height=1.5cm
                    ] (legendBox) at (0, -11.0) {};

                    \node[safe, minimum width=2.5cm, text width=2cm, scale=0.8, label={}]
                        at ($(legendBox.west)+(2.0,0)$) {Safe move};

                    \node[heur, minimum width=2.5cm, text width=2cm, scale=0.8, label={}]
                        at ($(legendBox.west)+(5.5,0)$) {Heuristic};

                    \node[right, text=gray!80, font=\scriptsize\sffamily, align=left]
                        at ($(legendBox.west)+(7.0,0)$) {Labels \textbf{[S]} and \textbf{[H]}\\indicate strategy};
                \end{tikzpicture}%
            }
        \else
            \resizebox{\linewidth}{!}{%
                \begin{tikzpicture}[
                    node distance=1.2cm and 1.0cm,
                    base/.style={
                        rectangle,
                        rounded corners=3pt,
                        line width=1pt,
                        minimum width=38mm,
                        text width=36mm,
                        inner sep=3mm,
                        align=center,
                        font=\small\sffamily
                    },
                    safe/.style={
                        base,
                        draw=cbBlue!70!black,
                        fill=cbBlue!25,
                        label={[anchor=north east, font=\scriptsize\bfseries, text=cbBlue!70!black, inner sep=2pt, yshift=-1pt]north east:[S]}
                    },
                    heur/.style={
                        base,
                        draw=cbOrange!70!black,
                        fill=cbOrange!25,
                        dashed,
                        label={[anchor=north east, font=\scriptsize\bfseries, text=cbOrange!70!black, inner sep=2pt, yshift=-1pt]north east:[H]}
                    },
                    line/.style={
                        draw=gray!80,
                        line width=1pt,
                        rounded corners=4pt,
                        ->,
                        >=Stealth
                    }
                ]

                    % Level 0
                    \node[safe] (root) at (0,0) {\(\displaystyle \int \frac{4}{(1-x^2)^{5/2}}\,dx\)};

                    % Level 1
                    \node[safe] (factor) at (-4.2, -2.8) {Factor constants\\restrict \(|x|<1\)};
                    \node[heur] (letu)   at ( 4.2, -2.8) {Let \(u = 1-x^2\)};

                    % Level 2
                    \node[heur] (subs)   at (-6.5, -6.0) {Substitute \(x=\sin y\)};
                    \node[heur] (sinh)   at (-2.0, -6.0) {Try \(x=\tanh u\)\\(hyperbolic twin)};
                    \node[heur] (stall)  at ( 4.2, -6.0) {Heuristic stalls\\backtrack};

                    % Level 3
                    \node[safe] (dx)     at (-8.8, -9.0) {Use \(dx=\cos y\,dy\)};
                    \node[safe] (reduce) at (-4.2, -9.0) {Reduce to \(4\int \sec^4 y\,dy\)};

                    % Edges
                    \draw[line] (root.south) -- ++(0,-0.6) -| (factor.north);
                    \draw[line] (root.south) -- ++(0,-0.6) -| (letu.north);

                    \draw[line] (factor.south) -- ++(0,-0.6) -| (subs.north);
                    \draw[line] (factor.south) -- ++(0,-0.6) -| (sinh.north);

                    \draw[line] (letu) -- (stall);

                    \draw[line] (subs.south) -- ++(0,-0.6) -| (dx.north);
                    \draw[line] (subs.south) -- ++(0,-0.6) -| (reduce.north);

                    % Legend
                    \node[
                        draw=gray!30,
                        rounded corners,
                        fill=white,
                        inner sep=8pt,
                        minimum width=10cm,
                        minimum height=1.5cm
                    ] (legendBox) at (0, -11.0) {};

                    \node[safe, minimum width=2.5cm, text width=2cm, scale=0.8, label={}]
                        at ($(legendBox.west)+(2.0,0)$) {Safe move};

                    \node[heur, minimum width=2.5cm, text width=2cm, scale=0.8, label={}]
                        at ($(legendBox.west)+(5.5,0)$) {Heuristic};

                    \node[right, text=gray!80, font=\scriptsize\sffamily, align=left]
                        at ($(legendBox.west)+(7.0,0)$) {Labels \textbf{[S]} and \textbf{[H]}\\indicate strategy};
                \end{tikzpicture}%
            }
        \fi

        % Keep the caption free of inline math; it wraps poorly in some EPUB renderers.
        \caption{Transformation tree for the running example integral; badges \textbf{[S]}/\textbf{[H]} mark safe vs.\ heuristic moves; the dashed branch mirrors the sine substitution. Use it when diagnosing where a solve attempt branched and why backtracking was required.}
        \label{fig:lec3_transform_tree}
\end{figure}

Use \Cref{fig:lec3_transform_tree} as the derivation anchor for this section.

\paragraph{Example:} For the integral problem, the root node is the original integral. From there, we branch into applying different substitutions or algebraic manipulations, such as
\[
\begin{aligned}
\text{Apply substitution } u=\tan(x) &\Rightarrow \text{integration by parts} \\
&\Rightarrow \text{inverse trig identities} \Rightarrow \cdots
\end{aligned}
\]

\paragraph{Safe vs. Heuristic Transformations:}
\begin{itemize}
  \raggedright
  \item \textbf{Safe transformations} are guaranteed to preserve equivalence and progress towards a solution.
  \item \textbf{Heuristic transformations} may or may not lead to a solution; they are attempts that carry risk but can be beneficial.
\end{itemize}

\paragraph{Backtracking:} If a branch leads to no solution, the system must backtrack to a previous node and try alternative transformations. This requires the ability to:
\begin{itemize}
  \item \emph{Freeze} the current state before branching.
  \item \emph{Restore} previous states upon failure (e.g., by pushing serialized expression trees and associated metadata onto a stack for later reinstatement).
\end{itemize}
In practice this corresponds to pushing serialized expression trees (i.e., deep copies of the tree structure together with any transformation metadata) onto a stack so they can be reinstated after unsuccessful exploratory steps.

\subsection{Algorithmic Outline for Symbolic Problem Solving}
\label{sec:symbolic_algorithmic_outline_for_symbolic_problem_solving}

The general algorithm for solving symbolic problems such as integrals can be summarized as follows:

\begin{enumerate}
  \item \textbf{Define the goal:} For example, express the integral in terms of known functions from a table.
  \item \textbf{Enumerate transformations:} List all possible safe and heuristic transformations applicable to the current expression.
  \item \textbf{Apply safe transformations:} Attempt all safe transformations and check if the problem is solved.
  \item \textbf{If not solved, apply heuristic transformations:} Attempt heuristic transformations to explore alternative paths; common template hits include \(\int f'(x)/f(x)\,dx \to \log|f(x)|+C\) and \(\int r'(x)e^{r(x)}\,dx \to e^{r(x)}+C\).
  \item \textbf{Branch and backtrack:} For each transformation, branch the search tree. If a branch fails, backtrack and try other branches.
  \item \textbf{Use heuristics to guide search:} For example, use functional composition depth or cost metrics to prioritize branches.
  \item \textbf{Terminate cleanly:} Stop when a closed-form antiderivative is found, or when depth/time budgets are exceeded without success; optional numeric residual tests can accept approximate solutions.
\end{enumerate}

\paragraph{Note:} This approach resembles a \emph{greedy search} with backtracking, but it does not guarantee an optimal or even successful solution in all cases.

    \begin{tcolorbox}[summarybox,breakable,title={Transformation-tree search (pseudocode)}]
\footnotesize
\begin{verbatim}
function SolveIntegral(f0,
                       domain=(-1,1),
                       depth_limit=8,
                       time_limit=2s,
                       eps_abs=1e-6,
                       eps_rel=1e-6,
                       samples=24):
    stack <- [(f0, domain, empty_history, depth=0)]
    start <- clock()
    best  <- {status="fail",
              F=None,
              residual=None,
              history=[],
              domain=domain}
    while stack not empty:
        current, dom, history, depth <- pop(stack)
        if clock() - start > time_limit
           or depth > depth_limit:
            continue
        if passes_residual_test(current, f0, dom,
                                eps_abs, eps_rel, samples):
            res = residual(current, f0, dom, samples)
            return {status="closed_form",
                    F=current,
                    residual=res,
                    history=history,
                    domain=dom}
        safe, heuristic <- enumerate_transforms(current, dom)
        for T in safe:
            g, new_dom <- apply(T, current, dom)
            push(stack,
                 (g, new_dom, history + [T], depth+1))
        for H in heuristic (ordered by cost)
             when depth+1 <= depth_limit:
            g, new_dom <- apply(H, current, dom)
            push(stack,
                 (g, new_dom, history + [H], depth+1))
    return best
\end{verbatim}
\normalsize
The pseudocode mirrors the narrative: record the original integrand \(f_0\), track the current domain/branch, apply safe transforms eagerly, explore heuristic branches within time/depth budgets, and only accept a candidate antiderivative once a sampled residual check (absolute or relative) passes on points inside the declared domain; return a clear status/history/domain either way.

\paragraph{Residual test implementation.} At each candidate \(F\), sample \(K\) points inside the current domain but away from singularities and branch points, and form \(R=\max_i |F'(x_i)-f_0(x_i)|\). Accept if \(R \le \varepsilon_{\text{abs}}\) or \(R/(1+\max_i |f_0(x_i)|)\le \varepsilon_{\text{rel}}\). Automatic differentiation or a high-order finite difference (step \(h=O(\sqrt{\varepsilon_{\text{machine}}})\)) keeps the check numerically stable. As substitutions shrink the domain, shrink the sample set and log the updated interval alongside the history.
\end{tcolorbox}

\begin{tcolorbox}[summarybox,title={Termination policies and numeric fallbacks}]
\begin{itemize}
    \item \textbf{Budgeting:} Cap depth, number of heuristic branches, and runtime (e.g., depth limit \(D=8\), two-second wall clock). When limits are reached, report ``no elementary antiderivative within budget \(D\)'' rather than looping forever.
    \item \textbf{Residual checks:} Differentiate candidate antiderivatives symbolically and numerically. Sample points inside the declared domain (away from poles) and accept only if \( \max_i |F'(x_i) - f(x_i)| \le \varepsilon_{\text{abs}}\) or the relative tolerance passes; otherwise prune or refine before returning.
    \item \textbf{Numeric escape hatch:} Switch to adaptive quadrature (e.g., Gauss--Kronrod) once symbolic attempts fail; return both the numeric estimate and the failed transformation history so users can adjust heuristics, noting that the numeric value is not a closed form.
    \item \textbf{Domain reminders:} When substitutions shrink domains (e.g., \(x=\sin y\) enforces \(|x|\le1\)), log the restriction and branch choice so the numeric fallback samples within the valid range and the report is reproducible.
\end{itemize}
\end{tcolorbox}
\begin{table}[t]
\centering
% Avoid inline math in captions; it wraps poorly in some EPUB renderers.
\caption{Table: Transformation toolkit (safe vs.\ heuristic). Preconditions keep domains/branches explicit (e.g., restrictions like ``x in (-1,1)'' for square-root expressions); principal branches unless noted.}
\small
\begin{tabularx}{0.96\linewidth}{@{}>{\raggedright\arraybackslash}p{0.22\linewidth} >{\raggedright\arraybackslash}X >{\raggedright\arraybackslash}X @{}}
\toprule
 & \textbf{Safe} & \textbf{Heuristic} \\
\midrule
Constant factor & \(\int a\,g(x)\,dx = a\int g(x)\,dx\) (no domain change). & Completing the square before attempting trig substitutions; track any resulting branch cuts. \\
Linear substitution & \(u=ax+b,\;dx=du/a\) with \(a\neq0\), invertible on the stated interval. & Trigonometric substitutions \(x=\sin u,\;x=\tan u,\;t=\tan(x/2)\) with domains \(u\in(-\tfrac{\pi}{2},\tfrac{\pi}{2})\) or stated principal branches. \\
Polynomial division / partial fractions & Split improper rational functions into polynomial + proper fraction where denominators stay nonzero on the domain. & Rationalising substitutions such as \(x=1/u\) or \(x=u^2\) to expose hidden symmetry; avoid zeros/poles introduced by the map. \\
Log-derivative pattern & \(\int f'(x)/f(x)\,dx = \log|f(x)|+C\) when \(f(x)\neq 0\) on the domain. & Template lookups (Beta/Gamma forms with parameter sign conditions, exponential-times-polynomial motifs, etc.). \\
\bottomrule
\end{tabularx}
\end{table}

\paragraph{Worked example: Beta template vs.\ numeric fallback}
Consider the Beta integral
\[
I(a,b) = \int_0^1 x^{a-1}(1-x)^{b-1}\,\mathrm{d}x, \qquad a,b>0.
\]
Safe transformations (factor constants, recognize the Beta template) immediately identify the elementary value \(B(a,b)=\Gamma(a)\Gamma(b)/\Gamma(a+b)\). By contrast, the perturbed integral
\[
\int_0^1 x^{a-1}(1-x)^{b-1}\log(1+x)\,\mathrm{d}x
\]
fails the template check after all safe moves. The solver therefore (i) records the unmet template, (ii) pushes a heuristic branch such as differentiation under the integral sign, and (iii) if the branch exceeds time/depth budgets, falls back to adaptive quadrature with the reported residual \(|I_{\text{numeric}}-I_{\text{candidate}}|\). This concrete pattern---try Beta/Gamma reduction, else return a certified numeric answer---embodies the policy described in the termination box.

\paragraph{Failure path with certified numeric residual.} Setting \(a=\tfrac{3}{2}, b=2\) in the perturbed integral above illustrates the full fallback. Safe moves reduce the plain Beta integral to \(B(3/2,2)=4/15\), but the extra \(\log(1+x)\) term triggers every heuristic branch (integration by parts, differentiation under the integral sign, series expansion) without yielding a closed form before the default depth limit \(D=8\). The solver then hands the integrand to an adaptive Gauss--Kronrod routine, which returns \(I_{\text{numeric}} \approx 0.0915453885\) with an internal error certificate \(<3\times 10^{-7}\); this is a certified quadrature value rather than a closed form. The residual check
\[
|I_{\text{numeric}} - I_{\text{previous refine}}| \le 3\times 10^{-7}
\]
is attached to the report along with the failed transformation history, making it explicit that no elementary antiderivative was located within the allotted budget even though a numerically reliable answer exists.

\subsection{Discussion: What this example illustrates}
\label{sec:symbolic_discussion_what_this_example_illustrates}

Under the operational framing in \Cref{chap:intro}, the integrator exhibits several ingredients associated with intelligent problem solving: it maintains an explicit state (the current expression), chooses actions (transformations), manages contingencies (branching and backtracking), and verifies results with a crisp goal test (differentiate and check the residual). At the same time, it is limited: it does not learn new transformations from data, and its effectiveness depends on a human-designed library of moves and heuristics.

Not every heuristic is helpful. For instance, applying \(x = \tan y\) to \(\int (1 + x^2)^{3/2} \, dx\) looks attractive because \(1+\tan^2 y = \sec^2 y\), yet it transforms the problem into \(\int \sec^5 y \, dy\), which is more complicated than the original integral. In a transformation-tree implementation this branch simply backtracks and explores alternatives (e.g., \(x = \tanh u\) for \(|x|<1\) or \(x=\cosh u\) for \(|x|>1\)), underscoring why explicit search discipline and residual checks are essential.

This contrast helps position the data-driven chapters that follow, where the system's ``actions'' are parameter updates guided by loss functions and validation checks.

% Connection to statistical learning (keep as an in-flow bridge, not a TOC heading).
\paragraph{Connection to statistical learning.} Symbolic integration is a clean playground for thinking about representations, action sequences, and verification. In data-driven modeling, the objects change (datasets, models, and losses), but the system-level pattern is similar: choose a hypothesis class, optimize an objective under resource constraints, and validate that the result generalizes.

\begin{tcolorbox}[summarybox,title={Connection: transformation search vs.\ empirical risk minimization}]
\begin{itemize}
    \item \textbf{Goal test:} residual check \(\max_{x\in S}|F'-f|\le\varepsilon\) vs.\ performance on held-out data.
    \item \textbf{Inductive bias:} safe/heuristic precedence vs.\ model class and regularization that shape what is learnable.
    \item \textbf{Budget:} depth/time limits vs.\ compute/epoch budgets and early stopping.
\end{itemize}
\end{tcolorbox}

\medskip
\begin{tcolorbox}[summarybox,title={Key takeaways}]
\textbf{Minimum viable mastery}
\begin{itemize}
    \item Symbolic integration is a compact example of a goal-driven system: represent state, apply meaning-preserving actions, and verify outcomes.
    \item Safe moves encode guaranteed transformations; heuristic moves trade certainty for coverage and require backtracking discipline.
    \item Residual checks act as a crisp goal test: differentiate a candidate and measure whether it agrees with the original integrand on the declared domain.
\end{itemize}
\medskip
\textbf{Common pitfalls}
\begin{itemize}
    \item Losing the system-level point in calculus detail: always name the state, action, heuristic, and goal test.
    \item Ignoring domains/branches: substitutions can shrink domains, introduce branch cuts, and invalidate a ``correct'' algebraic rewrite.
    \item Treating heuristics as proofs: heuristic branches must be verified (or backtracked), not trusted.
\end{itemize}
\end{tcolorbox}

\begin{tcolorbox}[summarybox,title={Exercises and lab ideas}]
\begin{itemize}
    \item Implement a minimal example from this chapter and visualize intermediate quantities (plots or diagnostics) to match the pseudocode.
    \item Stress-test a key hyperparameter or design choice discussed here and report the effect on validation performance or stability.
    \item Re-derive one core equation or update rule by hand and check it numerically against your implementation.
\end{itemize}
\medskip
\noindent\textbf{If you are skipping ahead.} Keep the pattern vocabulary: safe vs.\ heuristic moves, explicit budgets, and residual/verification checks. The data-driven chapters reuse the same discipline (objective, constraints, and validation) even though the ``actions'' become parameter updates.
\end{tcolorbox}

\medskip
\paragraph{Where we head next.} For the data-driven thread (datasets, objectives, diagnostics, classification), continue to \Cref{chap:supervised,chap:logistic}. For nonlinear function classes and nonconvex training dynamics, continue through \Crefrange{chap:perceptron}{chap:mlp} and the chapters that follow.


